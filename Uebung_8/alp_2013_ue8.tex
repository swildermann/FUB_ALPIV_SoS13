\documentclass[11pt,a4paper,DIV=10,]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancybox}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{colortbl}

% Define user colors using the RGB model
\definecolor{dunkelgrau}{rgb}{0.8,0.8,0.8}
\definecolor{hellgrau}{rgb}{0.95,0.95,0.95}
\definecolor{middlegray}{rgb}{0.5,0.5,0.5}
\definecolor{lightgray}{rgb}{0.8,0.8,0.8}
\definecolor{orange}{rgb}{0.8,0.3,0.3}
\definecolor{yac}{rgb}{0.6,0.6,0.1}

% Zitation und Literaturverzeichnis
\usepackage[normal,font={small,color=black}, labelfont=bf,figurename=Abb.]{caption}
\usepackage{cite}
\usepackage{url}
\bibliographystyle{unsrtnat}
\usepackage[numbers]{natbib}
%\usepackage[T1]{fontenc}

% Formatierung für das Listing
\lstset{
   basicstyle=\scriptsize\ttfamily,
   keywordstyle=\bfseries\ttfamily\color{orange},
   stringstyle=\color{green}\ttfamily,
   commentstyle=\color{middlegray}\ttfamily,
   emph={square}, 
   emphstyle=\color{blue}\texttt,
   emph={[2]root,base},
   emphstyle={[2]\color{yac}\texttt},
   showstringspaces=false,
   flexiblecolumns=false,
   tabsize=2,
   numbers=left,
   numberstyle=\tiny,
   numberblanklines=true,
   stepnumber=1,
   numbersep=10pt,
   xleftmargin=15pt
}

\begin{document}
% ==== HEADER ==== 
\subsection*{ALP4 SoSe 2013, Di. 16-18}
\section*{Lösung Übungsblatt 8}
\textbf{Christoph van Heteren-Frese (Matr.-Nr.: 4465677)} \\ \textbf{Sven Wildermann (Matr.-Nr.: 4567553)}\\
Tutor: Alexander Steen, eingereicht am \today\\
\hrule
% === HEADER END ===
\section*{Aufgabe 1}
\subsection*{a)}
Das Paket \texttt{rwmutex.go} implementiert ein spezielles Schloss, das zwar viele Prozesse lesen, aber nur einen schreiben lässt. Es werden dafür vier Zugriffsfunktionen definiert: \texttt{RLock()}, \texttt{RUnlock()}, \texttt{Lock() }und \texttt{Unlock()}. Will ein Prozess den Mutex für den Schreibzugriff nutzen obwohl gerade andere Prozesse lesen, wird dieser blockiert.
Grundlage der Erläuterung ist folgendes kleines Beispiel:
\lstinputlisting{rwmutex_exp.go}
\subsection*{b)}
\subsection*{c)}
\section*{Aufgabe 2}
\section*{Aufgabe 3}
Algorithmus in Pseudocode.
\begin{lstlisting}
 // Variabeldeklarationen
 type objects struct {
     Enum groesse = {gross, mittel, klein}
     bool richtung
     time timestamp_incoming}
 mainqueue (queue)objects
 leftqueue (queue)objects
 rightqueue (queue)objects
 islocked int
 
 // Algorithmus
 func add_object(new objects){
      // 0 = von links nach rechts
      // 1 = von rechts nach links 
     if new.richtung=0{
	    leftqueue.add(new)
      }else{
	    rightqueue.add(new)
      }
      if mainqueue.isEmpty{
	     // wenn es das erste Element ist,
	     // wird die Aktualisierung angestossen
             mainqueue.add(new)
             objekte_aktualisieren()
      }else{
	    //sonst nicht
             mainqueue.add(new)
      }
  }
 func objekte_aktualisieren(){
      current objects;
      // sortiert die Elemente nach Einfügezeit
      mainqueue.sort(timestamp)
      leftqueue.sort(timestamp)
      rightqueue.sort(timestamp)
      //überpruefen ob der Weg frei ist und ob ein 
      // Objekt den Weg passieren will
      if islocked == 0 && (not mainqueue.isEmpty){
	    current = mainqueue.get
	    if current.richtung==0{
		  // prüfe nach der Reihe ob es in lefftqueue 
		  // weitere Elemente gibt, die mit current
		  // auf den Weg gehen können. 
		  // Sende diese inkl. current los und lösche Sie aus 
		  // den queues, erhöhe jeweils islocked um die Anzahl
		  // der losgeschickten Elemente
	    }else if current.richtung==1{
		  // prüfe nach der Reihe ob es in rightqueue 
		  // weitere Elemente gibt, die mit current
		  // auf den Weg gehen können. 
		  // Sende diese inkl. current los und lösche Sie aus 
		  // den queues, erhöhe jeweils islocked um die Anzahl
		  // der losgeschickten Elemente
           }
	    
	    
      }
 
 }
 
 func objekt_ist_angekommen(){
      // wird vom Objekt aufgerufen
      // sobald ein Objekt angekommen ist
      islocked.lock();
      islocked--;
      islocked.unlock();
      objekte_aktualisieren();
 }
      
 
\end{lstlisting}

Dadurch dass die Queues nach der Einfügezeit der Objekte sortiert werden führt auch ein nebenläufiges einfügen zur korrekten Reihenfolge der Elemente in der Queue. Sobald entweder ein Objekt angekommen ist oder ein Objekt in die leere haupt-queue eingefügt wird, wird ``objekte-aktualisieren'' ausgeführt.
Diese Funktion überprüft erst, welches das am längsten wartende Objekt ist und dann welche Elemente aus der Queue der selben Richtung mit diesem Element möglicherweise zusammen losgeschickt werden könnten. Diese werden dann alle zusammen losgelassen (Barriere wird geöffnet). Um einen Überblick über die 
Anzahl der zur Zeit reisenden Objekte zu erhalten, wird der Counter islocked um den entsprechenden Wert erhöht. Sobald die einzelnen Elemente am Ziel angekommen sind, führen sie objekt-ist-angekommen() aus, der den Counter schrittweise wieder verringert. So wird in der Funktion objekte-aktualisieren sicher gestellt, dass keine neuen Objekte frei gelassen werden wenn noch nicht alle Objekte wieder angekommen sind. 

\section*{Aufgabe 4}

\end{document}
